SET SERVEROUTPUT ON;

DROP INDEX SORTARE_DATA;
DROP INDEX AFISARE_BADGE;
DROP INDEX LOGARE;
DROP INDEX CATEGORII_PREFERATE;
DROP INDEX INTREBARI_CATEGORII_PREFERATE;
DROP INDEX CAUTARE_TAG_URI;
DROP INDEX AFISARE_RASPUNSURI;
DROP INDEX ID_QUESTION_QUESTIONS_KEYWORDS;
DROP TABLE SOCIAL_NETWORK_LOG_IN;
DROP TABLE ANSWERS_DISLIKES;
DROP TABLE ANSWERS_LIKES;
DROP TABLE QUESTIONS_DISLIKES;
DROP TABLE QUESTIONS_LIKES;
DROP TABLE ANSWERS_QUESTIONS_PROFILES;
DROP TABLE PROFILES_CATEGORIES;
DROP TABLE QUESTIONS_TAGS;
DROP TABLE PROFILES_BADGES;
DROP TABLE QUESTIONS_KEYWORDS;
DROP TABLE ANSWERS;
DROP TABLE QUESTIONS;
DROP TABLE CATEGORIES;
DROP TABLE PROFILES;
DROP TABLE TAGS;
DROP TABLE KEYWORDS;
DROP TABLE BADGES;
DROP SEQUENCE SEQ_FOR_ANSWERS;
DROP SEQUENCE SEQ_FOR_PROFILES;
DROP SEQUENCE SEQ_FOR_CATEGORIES;
DROP SEQUENCE SEQ_FOR_QUESTIONS;
DROP SEQUENCE SEQ_FOR_TAGS;
DROP SEQUENCE SEQ_FOR_KEYWORDS;
DROP SEQUENCE SEQ_FOR_BADGES;
  CREATE TABLE PROFILES
    (
      ID_PROFILE INTEGER NOT NULL PRIMARY KEY,
      PASSWD     VARCHAR2(30) NOT NULL,
      USERNAME   VARCHAR2(30) NOT NULL UNIQUE,
      FIRST_NAME VARCHAR2(30),
      LAST_NAME  VARCHAR2(30),
      AGE        INTEGER,
      EMAIL      VARCHAR2(60) NOT NULL UNIQUE,
      COUNTRY    VARCHAR2(60),
      CITY       VARCHAR2(60),
      IS_ADMIN   INTEGER DEFAULT 0 CHECK (IS_ADMIN  IN (0,1)),
      IS_BANNED  INTEGER DEFAULT 0 CHECK (IS_BANNED IN (0,1))
    );
  /
  CREATE TABLE SOCIAL_NETWORK_LOG_IN
    (
      SOCIAL_NETWORK_ID VARCHAR2(30) PRIMARY KEY,
      ID_PROFILE        INTEGER NOT NULL ,
      CONSTRAINT ID_SOCIAL_PROFILE FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE
    );
  /
  CREATE TABLE CATEGORIES
    (
      ID_CATEGORY   INTEGER NOT NULL PRIMARY KEY,
      NAME_CATEGORY VARCHAR2(30) UNIQUE
    );
  /
  CREATE TABLE QUESTIONS
    (
      ID_QUESTION      INTEGER NOT NULL PRIMARY KEY,
      QUESTION_CONTENT VARCHAR2(500) NOT NULL,
      TIME_POSTED      DATE,
      ID_CATEGORY      INTEGER NOT NULL ,
      ID_PROFILE       INTEGER NOT NULL ,
      NMB_VIEWS        INTEGER DEFAULT 0,
      CONSTRAINT ID_PROF_QUES FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE ,
      CONSTRAINT ID_CAT_QUES FOREIGN KEY (ID_CATEGORY) REFERENCES CATEGORIES(ID_CATEGORY) ON DELETE CASCADE
    );
  /
CREATE TABLE ANSWERS
  (
    ID_ANSWER INTEGER NOT NULL PRIMARY KEY,
    ANSW_CONT VARCHAR2(500)
  );
/
CREATE TABLE ANSWERS_LIKES
  (
    ID_PROFILE,
    ID_ANSWER,
    CONSTRAINT ID_PROF_ANSW_LIKE FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE,
    CONSTRAINT ID_ANSW_PROF_LIKE FOREIGN KEY (ID_ANSWER) REFERENCES ANSWERS(ID_ANSWER) ON DELETE CASCADE
  );
/
CREATE TABLE ANSWERS_DISLIKES
  (
    ID_PROFILE,
    ID_ANSWER,
    CONSTRAINT ID_PROF_ANSW_DISLIKE FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE,
    CONSTRAINT ID_ANSW_PROF_DISLIKE FOREIGN KEY (ID_ANSWER) REFERENCES ANSWERS(ID_ANSWER) ON DELETE CASCADE
  );
/
CREATE TABLE QUESTIONS_LIKES
  (
    ID_PROFILE,
    ID_QUESTION,
    CONSTRAINT ID_PROF_QUES_LIKE FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE,
    CONSTRAINT ID_QUES_PROF_LIKE FOREIGN KEY (ID_QUESTION) REFERENCES QUESTIONS(ID_QUESTION) ON DELETE CASCADE
  );
/
CREATE TABLE QUESTIONS_DISLIKES
  (
    ID_PROFILE,
    ID_QUESTION,
    CONSTRAINT ID_PROF_QUES_DISLIKE FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE,
    CONSTRAINT ID_QUES_PROF_DISLIKE FOREIGN KEY (ID_QUESTION) REFERENCES QUESTIONS(ID_QUESTION) ON DELETE CASCADE
  );
/
CREATE SEQUENCE SEQ_FOR_ANSWERS START WITH 1 INCREMENT BY 1 NOMAXVALUE;
  /
CREATE TRIGGER ANSWERS_ID BEFORE
  INSERT ON ANSWERS FOR EACH ROW BEGIN
  SELECT SEQ_FOR_ANSWERS.NEXTVAL INTO :NEW.ID_ANSWER FROM DUAL;
END;
/
CREATE SEQUENCE SEQ_FOR_PROFILES START WITH 1 INCREMENT BY 1 NOMAXVALUE;
  /
CREATE TRIGGER PROFILES_ID BEFORE
  INSERT ON PROFILES FOR EACH ROW BEGIN
  SELECT SEQ_FOR_PROFILES.NEXTVAL INTO :NEW.ID_PROFILE FROM DUAL;
END;
/
CREATE OR REPLACE VIEW CATEGORIES_LIST
AS
  SELECT NAME_CATEGORY FROM CATEGORIES;
  /
CREATE SEQUENCE SEQ_FOR_CATEGORIES START WITH 1 INCREMENT BY 1 NOMAXVALUE;
  /
CREATE TRIGGER CATEGORIES_ID BEFORE
  INSERT ON CATEGORIES FOR EACH ROW BEGIN
  SELECT SEQ_FOR_CATEGORIES.NEXTVAL INTO :NEW.ID_CATEGORY FROM DUAL;
END;
/
CREATE SEQUENCE SEQ_FOR_QUESTIONS START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE TRIGGER QUESTIONS_ID BEFORE
  INSERT ON QUESTIONS FOR EACH ROW BEGIN
  SELECT SEQ_FOR_QUESTIONS.NEXTVAL INTO :NEW.ID_QUESTION FROM DUAL;
END;
/
CREATE TABLE TAGS
  (
    ID_TAG   INTEGER NOT NULL PRIMARY KEY,
    TAG_NAME VARCHAR2(20) UNIQUE
  );
/
CREATE SEQUENCE SEQ_FOR_TAGS START WITH 1 INCREMENT BY 1 NOMAXVALUE;
  /
CREATE TRIGGER TAGS_ID BEFORE
  INSERT ON TAGS FOR EACH ROW BEGIN
  SELECT SEQ_FOR_TAGS.NEXTVAL INTO :NEW.ID_TAG FROM DUAL;
END;
/
CREATE TABLE KEYWORDS
  (
    ID_KEYWORD  INTEGER NOT NULL PRIMARY KEY,
    KEYWORD     VARCHAR2(30),
    APPEARENCES INTEGER
  );
/
CREATE SEQUENCE SEQ_FOR_KEYWORDS START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE TRIGGER KEYWORDS_ID BEFORE
  INSERT ON KEYWORDS FOR EACH ROW BEGIN
  SELECT SEQ_FOR_KEYWORDS.NEXTVAL INTO :NEW.ID_KEYWORD FROM DUAL;
END;
/
CREATE TABLE BADGES
  (
    ID_BADGE    INTEGER NOT NULL PRIMARY KEY,
    DESCRIPTION VARCHAR2(200)
  );
/
CREATE SEQUENCE SEQ_FOR_BADGES START WITH 1 INCREMENT BY 1 NOMAXVALUE;
  /
CREATE TRIGGER BADGES_ID BEFORE
  INSERT ON BADGES FOR EACH ROW BEGIN
  SELECT SEQ_FOR_BADGES.NEXTVAL INTO :NEW.ID_BADGE FROM DUAL;
END;
/
CREATE TABLE QUESTIONS_TAGS
  (
    ID_QUESTION INTEGER NOT NULL ,
    ID_TAG      INTEGER NOT NULL ,
    CONSTRAINT ID_QUES_TAG FOREIGN KEY (ID_QUESTION) REFERENCES QUESTIONS(ID_QUESTION) ON DELETE CASCADE,
    CONSTRAINT ID_TAG_QUES FOREIGN KEY (ID_TAG) REFERENCES TAGS(ID_TAG) ON DELETE CASCADE
  );
/
CREATE TABLE ANSWERS_QUESTIONS_PROFILES
  (
    ID_ANSWER   INTEGER NOT NULL ,
    ID_PROFILE  INTEGER NOT NULL,
    ID_QUESTION INTEGER NOT NULL,
    CONSTRAINT ID_PROF_QUES_ANSW FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE,
    CONSTRAINT ID_ANSW_QUES_PROF FOREIGN KEY (ID_ANSWER) REFERENCES ANSWERS(ID_ANSWER) ON DELETE CASCADE,
    CONSTRAINT ID_QUES_ANSW_PROF FOREIGN KEY (ID_QUESTION) REFERENCES QUESTIONS(ID_QUESTION) ON DELETE CASCADE
  );
/
CREATE TABLE PROFILES_CATEGORIES
  (
    ID_CATEGORY INTEGER NOT NULL ,
    ID_PROFILE  INTEGER NOT NULL ,
    CONSTRAINT ID_PROF_CAT FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE,
    CONSTRAINT ID_CAT_PROF FOREIGN KEY (ID_CATEGORY) REFERENCES CATEGORIES(ID_CATEGORY) ON DELETE CASCADE
  );
/
CREATE TABLE QUESTIONS_KEYWORDS
  (
    ID_QUESTION INTEGER NOT NULL ,
    ID_KEYWORD  INTEGER NOT NULL ,
    CONSTRAINT ID_QUES_KEYWRD FOREIGN KEY (ID_QUESTION) REFERENCES QUESTIONS(ID_QUESTION) ON DELETE CASCADE,
    CONSTRAINT ID_KEYWRD_QUES FOREIGN KEY (ID_KEYWORD ) REFERENCES KEYWORDS(ID_KEYWORD) ON DELETE CASCADE
  );
/
CREATE TABLE PROFILES_BADGES
  (
    ID_BADGE   INTEGER NOT NULL ,
    ID_PROFILE INTEGER NOT NULL ,
    CONSTRAINT ID_PROF_BADGE FOREIGN KEY (ID_PROFILE) REFERENCES PROFILES(ID_PROFILE) ON DELETE CASCADE,
    CONSTRAINT ID_BADGE_PROF FOREIGN KEY (ID_BADGE) REFERENCES BADGES(ID_BADGE) ON DELETE CASCADE
  );
/

CREATE INDEX LOGARE ON PROFILES
  (PASSWD,USERNAME
  );
/
EXPLAIN PLAN
SET STATEMENT_ID = 'log_in' FOR SELECT id_profile FROM profiles WHERE passwd='ewfwefwef' AND username='ewfwefwer';
SELECT PLAN_TABLE_OUTPUT
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, 'log_in','BASIC'));
/

CREATE INDEX CATEGORII_PREFERATE ON PROFILES_CATEGORIES
  (ID_PROFILE
  );
/

CREATE INDEX SORTARE_DATA ON QUESTIONS(TIME_POSTED);
/

CREATE INDEX INTREBARI_CATEGORII_PREFERATE ON QUESTIONS
  (
    ID_CATEGORY
  );
/
EXPLAIN PLAN
SET STATEMENT_ID = 'intreb_categ_pref' FOR SELECT * FROM
(SELECT  *
  FROM questions
  WHERE ID_CATEGORY IN
    (SELECT ID_CATEGORY FROM Profiles_categories WHERE ID_PROFILE=12
    )
  ORDER BY TIME_POSTED
)
WHERE ROWNUM BETWEEN 12 AND 15;
SELECT PLAN_TABLE_OUTPUT
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, 'intreb_categ_pref','BASIC'));
/

CREATE INDEX CAUTARE_TAG_URI ON QUESTIONS_TAGS
  (ID_TAG
  );
/
EXPLAIN PLAN
SET STATEMENT_ID = 'intreb_tag' FOR SELECT * FROM (SELECT ID_QUESTION FROM QUESTIONS_TAGS 
WHERE ID_TAG=(SELECT ID_TAG FROM TAGS 
                                   WHERE TAG_NAME='c++'))
WHERE ROWNUM BETWEEN 1 AND 30;
SELECT PLAN_TABLE_OUTPUT
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, 'intreb_tag','BASIC'));
/

CREATE INDEX AFISARE_RASPUNSURI ON ANSWERS_QUESTIONS_PROFILES
  (ID_QUESTION
  );
/
EXPLAIN PLAN
SET STATEMENT_ID = 'raspunsuri' FOR SELECT * FROM (SELECT * FROM ANSWERS
WHERE ID_ANSWER IN (SELECT ID_ANSWER FROM ANSWERS_QUESTIONS_PROFILES
                                                WHERE ID_QUESTION = 3))
WHERE ROWNUM BETWEEN 45 AND 10;
SELECT PLAN_TABLE_OUTPUT
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, 'raspunsuri','BASIC'));
/

CREATE INDEX ID_QUESTION_QUESTIONS_KEYWORDS ON QUESTIONS_KEYWORDS
  (
    ID_QUESTION
  );
/

CREATE INDEX AFISARE_BADGE ON PROFILES_BADGES(ID_PROFILE);
/
EXPLAIN PLAN
SET STATEMENT_ID = 'BADGE' FOR SELECT * FROM BADGES 
WHERE ID_BADGE IN  (SELECT ID_BADGE FROM PROFILES_BADGES
                        WHERE ID_PROFILE=4);
SELECT PLAN_TABLE_OUTPUT
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, 'BADGE','BASIC'));
/


CREATE OR REPLACE PACKAGE ACCESS_UTILS
IS
  FUNCTION LOG_IN
    (
      PASSWD_IN   IN VARCHAR2,
      USERNAME_IN IN VARCHAR2
    )
    RETURN INTEGER;
    
  FUNCTION INREGISTRARE
    (
      PASSWD_IN   IN VARCHAR2,
      USERNAME_IN IN VARCHAR2,
      EMAIL_IN    IN VARCHAR2
    )
    RETURN INTEGER;
END ACCESS_UTILS;
/
CREATE OR REPLACE PACKAGE BODY ACCESS_UTILS
IS
    FUNCTION LOG_IN
    (
      PASSWD_IN   IN VARCHAR2,
      USERNAME_IN IN VARCHAR2
    )
    RETURN INTEGER
  IS
  BEGIN
    SELECT ID_PROFILE FROM PROFILES 
    WHERE PASSWD=PASSWD_IN
    AND USERNAME=USERNAME_IN;
    RETURN ID_PROFILE;
  END ;
  
  FUNCTION INREGISTRARE
    (
      PASSWD_IN   IN VARCHAR2,
      USERNAME_IN IN VARCHAR2,
      EMAIL_IN    IN VARCHAR2
    )
    RETURN INTEGER
  IS
    PROFILE_IDD INTEGER;
  BEGIN
    INSERT
    INTO PROFILES
      (
        PASSWD,
        USERNAME,
        EMAIL
      )
      VALUES
      (
        PASSWD_IN,
        USERNAME_IN,
        EMAIL_IN
      );
    SELECT ID_PROFILE
    INTO PROFILE_IDD
    FROM PROFILES
    WHERE USERNAME=USERNAME_IN
    AND PASSWD    =PASSWD_IN;
    RETURN PROFILE_IDD;
  END;
END ACCESS_UTILS;
/
CREATE OR REPLACE PACKAGE PROFILE_UTILS
IS
  PROCEDURE EDIT_PASSWD(
      PASSWD_IN  IN VARCHAR2,
      PROFILE_ID IN INTEGER);
  PROCEDURE EDIT_USERNAME(
      USERNAME_IN IN VARCHAR2,
      PROFILE_ID  IN INTEGER);
  PROCEDURE EDIT_FIRST_NAME(
      FIRST_NAME_IN IN VARCHAR2,
      PROFILE_ID    IN INTEGER);
  PROCEDURE EDIT_LAST_NAME(
      LAST_NAME_IN IN VARCHAR2,
      PROFILE_ID   IN INTEGER);
  PROCEDURE EDIT_AGE(
      AGE_IN     IN INTEGER,
      PROFILE_ID IN INTEGER);
  PROCEDURE EDIT_EMAIL(
      EMAIL_IN   IN VARCHAR2,
      PROFILE_ID IN INTEGER);
  PROCEDURE EDIT_COUNTRY(
      COUNTRY_IN IN VARCHAR2,
      PROFILE_ID IN INTEGER);
  PROCEDURE EDIT_CITY(
      CITY_IN    IN VARCHAR2,
      PROFILE_ID IN INTEGER);
  FUNCTION VIEW_PROFILE(
      PROFILE_ID IN INTEGER)
    RETURN PROFILES%ROWTYPE;
END PROFILE_UTILS;
/
CREATE OR REPLACE PACKAGE BODY PROFILE_UTILS
IS
  PROCEDURE EDIT_PASSWD(
      PASSWD_IN  IN VARCHAR2,
      PROFILE_ID IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF PASSWD;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES SET PASSWD=PASSWD_IN WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  PROCEDURE EDIT_USERNAME(
      USERNAME_IN IN VARCHAR2,
      PROFILE_ID  IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF USERNAME;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES SET USERNAME=USERNAME_IN WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  PROCEDURE EDIT_FIRST_NAME(
      FIRST_NAME_IN IN VARCHAR2,
      PROFILE_ID    IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF FIRST_NAME;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES SET FIRST_NAME=FIRST_NAME_IN WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  PROCEDURE EDIT_LAST_NAME(
      LAST_NAME_IN IN VARCHAR2,
      PROFILE_ID   IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF LAST_NAME;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES SET LAST_NAME=LAST_NAME_IN WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  PROCEDURE EDIT_AGE(
      AGE_IN     IN INTEGER,
      PROFILE_ID IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF AGE;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES SET AGE=AGE_IN WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  PROCEDURE EDIT_EMAIL(
      EMAIL_IN   IN VARCHAR2,
      PROFILE_ID IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF EMAIL;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES SET EMAIL=EMAIL_IN WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  PROCEDURE EDIT_COUNTRY(
      COUNTRY_IN IN VARCHAR2,
      PROFILE_ID IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF COUNTRY;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES SET COUNTRY=COUNTRY_IN WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  PROCEDURE EDIT_CITY(
      CITY_IN    IN VARCHAR2,
      PROFILE_ID IN INTEGER)
  IS
    CURSOR MYCURSOR
    IS
      SELECT * FROM PROFILES WHERE ID_PROFILE=PROFILE_ID FOR UPDATE OF CITY;
      COUNTER INTEGER:=1;
  BEGIN
    FOR INDX IN MYCURSOR
    LOOP
      UPDATE PROFILES
      SET CITY=CITY_IN
      WHERE CURRENT OF MYCURSOR;
    END LOOP;
  END;
  FUNCTION VIEW_PROFILE(
      PROFILE_ID IN INTEGER)
    RETURN PROFILES%ROWTYPE
  IS
    PROFILE_INFO PROFILES%ROWTYPE;
  BEGIN
    SELECT * INTO PROFILE_INFO FROM PROFILES WHERE ID_PROFILE=PROFILE_ID;
    RETURN PROFILE_INFO;
  END;
END PROFILE_UTILS;
/

CREATE OR REPLACE PACKAGE QUESTIONS_ANSWERS IS
  PROCEDURE POST_ANSWER(VID_PROFILE IN INTEGER,VID_QUESTION IN INTEGER,ANSWER_CONTENT IN VARCHAR2);
  PROCEDURE POST_QUESTION(VID_PROFILE IN INTEGER,VQUESTION_CONTENT  IN VARCHAR2, VCATEGORY_NAME VARCHAR2);
  PROCEDURE DELETE_QUESTION(ID_QUESTION IN INTEGER);
  PROCEDURE DELETE_ANSWER(ID_ANSWER IN INTEGER);
  FUNCTION LIKE_QUESTION(ID_QUESTION IN INTEGER, ID_PROFILE IN INTEGER) RETURN INTEGER;
  FUNCTION DISLIKE_QUESTION(ID_QUESTION IN INTEGER, ID_PROFILE IN INTEGER) RETURN INTEGER;
  FUNCTION LIKE_ANSWER(ID_ANSWER IN INTEGER, ID_PROFILE IN INTEGER) RETURN INTEGER;
  FUNCTION DISLIKE_ANSWER(ID_ANSWER IN INTEGER, ID_PROFILE IN INTEGER) RETURN INTEGER;
  FUNCTION EDIT_ANSWER(ID_ANSWER IN INTEGER) RETURN BOOLEAN;
  FUNCTION EDIT_QUESTION(ID_QUESTION IN INTEGER) RETURN BOOLEAN;  
END QUESTIONS_ANSWERS;
/

CREATE OR REPLACE PACKAGE BODY QUESTIONS_ANSWERS IS

  PROCEDURE POST_ANSWER(VID_PROFILE IN INTEGER,VID_QUESTION IN INTEGER,ANSWER_CONTENT IN VARCHAR2) IS
  BEGIN
    INSERT INTO ANSWERS(ANSWER_CONT) VALUES (ANSWER_CONTENT);
    INSERT INTO ANSWERS_QUESTIONS_PROFILES(ID_ANSWER,ID_PROFILE,ID_QUESTION) VALUES(VID_PROFILE ,VID_QUESTION ,ANSWER_CONTENT );
  END;
  
  PROCEDURE POST_QUESTION(VID_PROFILE IN INTEGER,VQUESTION_CONTENT IN VARCHAR2, VCATEGORY_NAME VARCHAR2) IS
    ID_CAT INTEGER;
  BEGIN
    SELECT ID_CATEGORY INTO ID_CAT FROM CATEGORIES WHERE CATEGORY_NAME=VCATEGORY_NAME;
    INSERT INTO QUESTIONS(QUESTION_CONTENT,TIME_POSTED,ID_CATEGORY,ID_PROFILE) VALUES (VQUESTION_CONTENT,SYSDATE,ID_CAT,VID_PROFILE);
    INSERT INTO ANSWERS_QUESTIONS_PROFILES(ID_ANSWER,ID_PROFILE,ID_QUESTION) VALUES(VID_PROFILE ,VID_QUESTION ,ANSWER_CONTENT );
  END;
  
  PROCEDURE DELETE_QUESTION(VID_QUESTION IN INTEGER) IS
  BEGIN
    DELETE FROM QUESTIONS WHERE ID_QUESTION=VID_QUESTION;
  END;
  
  PROCEDURE DELETE_ANSWER(VID_ANSWER IN INTEGER) IS
  BEGIN
    DELETE FROM ANSWERS WHERE ID_ANSWER=VID_ANSWER;
  END;
  
  FUNCTION LIKE_QUESTION(VID_QUESTION IN INTEGER, VID_PROFILE IN INTEGER) RETURN INTEGER IS
    EXIST INTEGER:=0;
  BEGIN
    SELECT COUNT(*) INTO EXIST FROM QUESTIONS_LIKES WHERE VID_QUESTION=ID_QUESTION AND VID_PROFILE=ID_PROFILE;
    IF EXIST>0 THEN
      INSERT INTO QUESTIONS_LIKES(ID_QUESTION,ID_PROFILE) VALUES (VID_QUESTION,VID_PROFILE);
    
  END;
  
  FUNCTION DISLIKE_QUESTION(ID_QUESTION IN INTEGER, ID_PROFILE IN INTEGER) RETURN INTEGER;
  FUNCTION LIKE_ANSWER(ID_ANSWER IN INTEGER, ID_PROFILE IN INTEGER) RETURN INTEGER;
  FUNCTION DISLIKE_ANSWER(ID_ANSWER IN INTEGER, ID_PROFILE IN INTEGER) RETURN INTEGER;
  FUNCTION EDIT_ANSWER(ID_ANSWER IN INTEGER) RETURN BOOLEAN;
  FUNCTION EDIT_QUESTION(ID_QUESTION IN INTEGER) RETURN BOOLEAN;  
END QUESTIONS_ANSWERS;
/


CREATE OR REPLACE DIRECTORY CSV
AS
  'D:\GitHub\TW\baza de date(tot)';
  /
CREATE OR REPLACE FUNCTION LOAD_CSV(
  p_table              IN VARCHAR2,
  P_FILENAME           IN VARCHAR2,
  p_ignore_headerlines IN INTEGER DEFAULT 0,
  p_dir                IN VARCHAR2 DEFAULT 'CSV' ,
  p_delimiter          IN VARCHAR2 DEFAULT ',',
  p_optional_enclosed  IN VARCHAR2 DEFAULT '"' )
RETURN NUMBER
IS
  /***************************************************************************
  -- P_FILENAME
  -- The name of the flat file(a text file)
  --
  -- P_DIRECTORY
  -- Name of the directory where the file is been placed.
  -- Note: The grant has to be given for the user to the directory
  -- before executing the function
  --
  -- P_IGNORE_HEADERLINES:
  -- '1' to ignore importing headers.
  --
  -- P_DELIMITER
  -- By default the delimiter is used as ','
  --
  -- P_OPTIONAL_ENCLOSED
  -- By default the optionally enclosed is used as '"'
  **************************************************************************/
  l_input utl_file.file_type;
  l_theCursor INTEGER DEFAULT dbms_sql.open_cursor;
  l_lastLine  VARCHAR2(4000);
  l_cnames    VARCHAR2(4000);
  l_bindvars  VARCHAR2(4000);
  l_status    INTEGER;
  l_cnt       NUMBER DEFAULT 0;
  l_rowCount  NUMBER DEFAULT 0;
  l_sep       CHAR(1) DEFAULT NULL;
  L_ERRMSG    VARCHAR2(4000);
  V_EOF       BOOLEAN := false;
  v_query     VARCHAR2(500);
  e_name      EXCEPTION;
  PRAGMA EXCEPTION_INIT (e_name, -20999);
BEGIN
  l_cnt := 1;
  FOR TAB_COLUMNS IN
  (SELECT column_name,
    data_type
  FROM user_tab_columns
  WHERE table_name=p_table
  ORDER BY column_id
  )
  LOOP
    IF L_CNT      >1 THEN
      l_cnames   := l_cnames || tab_columns.column_name || ',';
      l_bindvars := l_bindvars ||
      CASE
      WHEN tab_columns.data_type IN ('DATE', 'TIMESTAMP(6)') THEN
        'to_date(:b' || l_cnt || ',''YYYY-MM-DD HH24:MI:SS''),'
      ELSE
        ':b'|| l_cnt || ','
      END;
    END IF;
    l_cnt := l_cnt + 1;
  END LOOP;
  l_cnames               := rtrim(l_cnames,',');
  L_BINDVARS             := RTRIM(L_BINDVARS,',');
  L_INPUT                := UTL_FILE.FOPEN( P_DIR, P_FILENAME, 'r' );
  IF p_ignore_headerlines > 0 THEN
    BEGIN
      FOR i IN 1 .. p_ignore_headerlines
      LOOP
        UTL_FILE.get_line(l_input, l_lastLine);
      END LOOP;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_eof := TRUE;
    END;
  END IF;
  IF NOT v_eof THEN
    V_QUERY:='insert into ' || p_table || '(' || l_cnames || ') values (' || l_bindvars ||')';
    dbms_sql.parse(l_theCursor,V_QUERY,dbms_sql.native );
    LOOP
      BEGIN
        utl_file.get_line( l_input, l_lastLine );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        dbms_output.put_line('eroare2');
        COMMIT;
        RETURN L_ROWCOUNT;
      END;
      IF LENGTH(l_lastLine) > 0 THEN
        FOR i IN 2 .. l_cnt-1
        LOOP
          dbms_sql.bind_variable( l_theCursor, ':b'||i, rtrim(ltrim( REGEXP_SUBSTR(l_lastline,'(^|,)("[^"]*"|[^",]*)',1,i-1),p_delimiter),p_delimiter));
        END LOOP;
        BEGIN
          l_status   := dbms_sql.execute(l_theCursor);
          l_rowCount := l_rowCount + 1;
        EXCEPTION
        WHEN OTHERS THEN
          L_ERRMSG := SQLERRM;
          dbms_output.put_line('eroare1');
          ROLLBACK;
          RAISE_APPLICATION_ERROR(-20999,L_ERRMSG||' at line '||l_rowCount);
        END;
      END IF;
    END LOOP;
    dbms_sql.close_cursor(l_theCursor);
    utl_file.fclose( l_input );
  END IF;
  RETURN L_ROWCOUNT;
END LOAD_CSV;
/
DECLARE
  ROWNB INTEGER;
BEGIN
  ROWNB:=LOAD_CSV('CATEGORIES','categories.csv');
  DBMS_OUTPUT.PUT_LINE(ROWNB);
END;
/

-----------------------------------bloc anonim de generare a profilelor
DECLARE
  VLENGTH     INTEGER;
  VPASSWD     VARCHAR2(30);
  VUSERNAME   VARCHAR2(30);
  VFIRST_NAME VARCHAR2(30);
  VLAST_NAME  VARCHAR2(30);
  VAGE        INTEGER;
  EMST        VARCHAR2(30);
  EMF         VARCHAR2(30);
  VEMAIL      VARCHAR2(60);
  VCOUNTRY    VARCHAR2(60);
  VCITY       VARCHAR2(60);
  VIS_ADMIN   INTEGER;
  VIS_BANNED  INTEGER;
BEGIN
  FOR I IN 1..1000
  LOOP
    SELECT dbms_random.value(6,30) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO VPASSWD FROM dual;
    SELECT dbms_random.value(6,30) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO VUSERNAME FROM dual;
    SELECT dbms_random.value(6,30) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO VFIRST_NAME FROM dual;
    SELECT dbms_random.value(6,30) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO VLAST_NAME FROM dual;
    SELECT dbms_random.value(1,200) INTO VAGE FROM dual;
    SELECT dbms_random.value(1,30) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO EMST FROM dual;
    SELECT dbms_random.value(1,25) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO EMF FROM dual;
    VEMAIL:=EMST||'@'||EMF||'.com';
    SELECT dbms_random.value(1,60) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO VCOUNTRY FROM dual;
    SELECT dbms_random.value(1,60) INTO VLENGTH FROM dual;
    SELECT dbms_random.string('U',VLENGTH) INTO VCITY FROM dual;
    SELECT dbms_random.value(0,1) INTO VIS_ADMIN FROM dual;
    SELECT dbms_random.value(0,1) INTO VIS_BANNED FROM dual;
    INSERT
    INTO PROFILES
      (
        PASSWD,
        USERNAME,
        FIRST_NAME,
        LAST_NAME,
        AGE,
        EMAIL,
        COUNTRY,
        CITY,
        IS_ADMIN,
        IS_BANNED
      )
      VALUES
      (
        VPASSWD,
        VUSERNAME,
        VFIRST_NAME,
        VLAST_NAME,
        VAGE,
        VEMAIL,
        VCOUNTRY,
        VCITY,
        VIS_ADMIN,
        VIS_BANNED
      );
  END LOOP;
END;
/

-------------------------------bloc anonim de generare a intrebarilor
DECLARE
  VLENGTH           INTEGER;
  VQUESTION_CONTENT VARCHAR2(500);
  VTIME_POSTED      DATE;
  VID_CATEGORY      INTEGER;
  VID_PROFILE       INTEGER;
  VNMB_VIEWS        INTEGER;
  NR_PROFILE        INTEGER;
BEGIN
  SELECT MAX(ROWNUM) INTO NR_PROFILE FROM PROFILES;
  FOR I IN 1..500000
  LOOP
    BEGIN
      SELECT dbms_random.value(1,300) INTO VLENGTH FROM dual;
      SELECT dbms_random.string('U',VLENGTH) INTO VQUESTION_CONTENT FROM dual;
      SELECT dbms_random.value(1,10) INTO VID_CATEGORY FROM dual;
      SELECT dbms_random.random INTO VLENGTH FROM dual;
      SELECT dbms_random.value(0,VLENGTH) INTO VNMB_VIEWS FROM dual;
      SELECT dbms_random.value(1,NR_PROFILE) INTO VID_PROFILE FROM dual;
      VTIME_POSTED:=TO_DATE(TRUNC(DBMS_RANDOM.value(TO_CHAR(DATE '1970-01-01 ','J'),TO_CHAR(SYSDATE,'J'))),'J');
      INSERT
      INTO QUESTIONS
        (
          QUESTION_CONTENT,
          TIME_POSTED,
          ID_CATEGORY,
          ID_PROFILE,
          NMB_VIEWS
        )
        VALUES
        (
          VQUESTION_CONTENT,
          VTIME_POSTED,
          VID_CATEGORY,
          VID_PROFILE,
          VNMB_VIEWS
        );
    EXCEPTION
    WHEN OTHERS THEN
      EXIT;
    END;
  END LOOP;
END;
/       
